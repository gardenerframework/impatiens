# 路由表

在
[[三层网络与数据交换机制介绍](..%2F%E4%B8%89%E5%B1%82%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D)]
一文中，简单介绍过子网、路由器和路由表。一个简单的认知就是路由器将不同的子网连接到一起，子网和子网之间想要通信，必须通过路由器的协助。
那么互联网的ip也有网络号和主机号，也就是互联网其实也是一个又一个的子网，这些网之间的数据交换也通过路由器完成的。

# 家庭网络

当一个家庭用网时通常来讲一个路由器就够了，它将计算机组成一个子网后与光猫的子网进行数据交换。

```plantuml
@startuml
!include  https://plantuml.s3.cn-north-1.jdcloud-oss.com/C4_Container.puml

Boundary(子网1, 子网, 192.168.0.0/24) {
    System(主机1, 192.168.0.108, 我的电脑/白色网口)
    Container(port1, 192.168.0.1, 路由器网关)
    主机1<-r-> port1
}
Boundary(子网2, 子网, 192.168.1.0/24) {
    System(主机2, 192.168.1.1, 联网光猫) #orange
    Container(port2, 192.168.1.2, 蓝色网口)
    port2 <-r-> 主机2
}

System(网站, 网站)

System(路由器, 家用路由器) #red
port1 <-u-> 路由器
路由器 <--> port2
主机2 <--> 网站
@enduml
```

需要注意的是，192.168.0.1(由于是红色的，因此叫做小红)
是192.168.0.0/24的默认路由，它负责把192.168.1.0/24的去往其它子网的数据包转出去。在转出去之前，它也要根据自己的路由表查数据怎么转。
在它的内部会有一张这样的路由表

```text
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         0.0.0.0         UG    100    0        0 WAN
192.168.0.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

也就是说，默认情况下，数据从WAN口出(送往联通光猫)
，去往192.168.0.0/24的数据，因为本身自己就有这个子网的ip，直接查mac地址发送。基于这样的路由表，
它把上网的包发给了192.168.1.1(联通的光猫，因为其在图上是橘黄色的，就称为橘猫)，现在来看看互联网的回包。

192,.168.1.1肯定是要用SNAT将内网地址转成联通给我们的互联网地址将包发出去，然后网站响应了数据后将数据返回给192.168.1.1的互联网地址，光猫根据SNAT的转换规则转换回发送前的内网地址。
那么这个内网地址应该是"192.168.1.2"？还是"192.168.0.108"？在此不妨假设是"192.168.0.108"

现在橘猫开始查自己的路由表，它的路由表长这样

```text
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         0.0.0.0         UG    100    0        0 光口
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

很好，没有有关192.168.0.0/24网络的任何信息，按照默认路由将数据发送给光口，光口虽然看到是个内网地址，但是本着转发的责任，无奈地说”好吧好吧，我发还不行吗“，于是响应就又回互联网去了

追踪一把路由看看(测试时主机ip已经变成**192.168.0.105**)

![内网地址trcert.png](内网地址trcert.png)

再实际ping一把

![img.png](ping不通.png)

我们的个人电脑相当于无法收到网站的响应从而打不开页面。

因此，真正的答案只能是小红在把上网的包递给橘猫前，首先使用了snat将源地址改为192.168.1.2，
这样回包才能先回到1.2，然后再由小红在192.168.0.0/24网段的网卡回给192.168.0.108

也就会说，如果想要橘猫能传包给192.168.0.0/24，需要告诉橘猫 192.168.0.0/24 ->
192.168.1.2，这样数据包会返回到小红，然后再根据路由表，从网口返回给192.168.0.108。

看到这里肯定很好奇，这两个路由器连到一起了，难道小红不能告诉他么自己能通往192.168.0.0/24么？还得人配？
答案是非常不幸，除非两个路由能彼此交换路径，否则互相只能手配。

我们现在不妨给家里加一个路由器，然后子网配置为192.168.2.0/24，这个路由器我买的时候是蓝色的，不妨叫它小蓝

```plantuml
@startuml
!include  https://plantuml.s3.cn-north-1.jdcloud-oss.com/C4_Container.puml

Boundary(子网1, 子网, 192.168.0.0/24) {
    System(主机1, 192.168.0.108, 我的电脑/白色网口)
    Container(port1, 192.168.0.1, 路由器网关)
    主机1<-r-> port1
}
Boundary(子网2, 子网, 192.168.1.0/24) {
    System(主机2, 192.168.1.1, 联网光猫) #orange
    Container(port2, 192.168.1.2, 蓝色网口) #red
    Container(port4, 192.168.1.3, 蓝色网口) #blue
    port2 <-d-> 主机2
    port4 <-d-> 主机2
}
Boundary(子网3, 子网, 192.168.2.0/24) {
    Container(port3, 192.168.2.1, 路由器网关)
    System(port6, 192.168.2.100, 另一台电脑)
    port6 -l-> port3 
}
System(网站, 网站)

System(路由器, 家用路由器, 小红) #red
System(路由器2, 家用路由器, 小蓝) #blue
port3<-u->路由器2
port1 <-u-> 路由器
路由器 <--> port2
路由器2 <--> port4
主机2 <--> 网站
@enduml
```

现在问题来了，我想和小蓝上面的电脑(192.168.2.100)互相ping一下，做得到还是做不到呢？
答案是做不到。因为

* 小红上没有子网192.168.2.0/24的任何转发规则，我也没能从路由器的页面上找到怎么添加以及关闭snat
* 小蓝上也一样，没有任何有关192.168.0.0/24的转发规则以及关闭snat
* 橘猫作为小红和小蓝的默认路由，也打算袖手旁观~无法添加转发规则

因此，这两个子网只是物理层能通(线连上了而已)

虽然它们都已经是个成熟的路由器了，但是还是彼此不能有效沟通

# 路由协议的必要性

家里几个路由器谁和谁也不同的情况在互联网上也很常见

假设网这么连的，6.6.6.6/24 -> 7.7.7.7/24 <- 8.8.8.8/24，再假设默认路由这么设置的

* 6.6.6.6的默认路由走转给7.7.7.7
* 8.8.8.8的默认路由走转给7.7.7.7
* 7.7.7.7的默认路由是转给9.9.9.9

于是6.6.6.6上如果没有8.8.8.8的路由设置，则6.6.6.6网络要发给8.8.8.8的包发给了9.9.9.9，而且还不知道9.9.9.9给转到哪，就算转到了8.8.8.8，响应的数据包能不能回来还是个事。
这导致网络工程师们需要在路由器上人肉配置一堆规则来保证数据传输的下一跳地址符合预期。
此外，如果6.6.6.6到7.7.7.7的路由器故障了，8.8.8.8和9.9.9.9的工程师们就要赶紧上去重新配置路由，标记到6.6.6.6和7.7.7.7之间的路由器出问题了，可能需要将去往6.6.6.6网络的包转给10.10.10.10。
要知道互联网上可不是几台路由器，而且你也不知道它什么时候坏，请问你看到这里想不想报名去做一个网络工程师？

因此，静态路由设置只能设置超小规模网络，比如家庭网络。真正的互联网或大型网络需要路由协议来辅助进行网络和网络之间的路径发现、交换、更新以及最短路径求取等。它使得7.7.7.7能告诉6.6.6.6，我还能通往8.8.8.8和9.9.9.9，如果你要去哪边，我告诉你个几个ip以及可能的延迟和跳数，你看你用哪个；
另外10.10.10.10最近抽疯，如果你有包经过它那你最好换个路径之类的。

# 主要的路由交换协议

路由协议的主要做法比较统一，自己将新的路径以及延迟等信息广播(IP广播)给周边的邻居，同时接受来自邻居的路由信息广播然后更新自己的数据。在介绍路由协议前，首先对几个名词介绍一下

### AS

AS是自治系统，通常是一个运营商，这个运营商下的所有路由器基于相同或者差不多相同的路由算法彼此互相通信。这很常见，如果一个运营商买了100个路由器带来了20多种算法和协议，那这堆路由器接在一起互相产生不了什么作用。
因此一个AS内部通常统一规划一种IGP

### IGP

内部网关协议，也就是一个AS内部大致采用的较为通用的路由协议和算法模型，省得路由器之间的协议和算法彼此不能兼容。目前主要的IGP协议有
RIP(距离矢量算法)和OSPF(链路状态)

### RIP

RIP(Route Information Protocol)：最简单的路由协议，此协议通常用在网络架构较为简单的小型网络环境，30秒广播一次路由表，最大跳数是15跳，基于矢量路由协议搞定最短路径。
RIP的收敛速度较慢，意思是网络拓扑如果发生变化(比如哪个路由器挂了)，RIP全网更新状态的速度不高

### OSPF

OSPF(Open Shortest Path First): 开放式最短路径优先，只有在链路状态发生变化时才泛洪告知周边邻居更新自己的路由表

### IS-IS

IS-IS(Intermediate System-to-Intermediate System，中间系统到中间系统)，也是链路状态算法，不过有了层次的概念。
IS-IS在路由域内采用两级的分层结构。一个大的路由域被分成一个或多个区域（Areas）。并定义了路由器的三种角色：Level-1、Level-2、Level-1-2。区域内的路由通过Level-1路由器管理，区域间的路由通过Level-2路由器管理

### EGP

一个AS内部有成千上万的路由器，这些路由器会使用IGP彼此达到尽可能的状态统一。但是AS并不是互联网，互联网是由一堆AS组成的。
于是AS之间要怎么弄？

### BGP

AS也可以被理解为是一个网络，只是这个网络包含了很多子网络。全世界的AS也通过路由器都连在一起所以才叫互联网。那么有一个问题，两个AS之间如果没有直接的联系，路径要怎么走？

![BGP.png](BGP.png)

比如这张图的N6和N1，至少跨了好几个AS。这时如果两个AS内的机器要通信，路径怎么选？

按照这篇博客[https://blog.csdn.net/z135733/article/details/124575717](https://blog.csdn.net/z135733/article/details/124575717)
的说法，BGP就是每一个AS从自己的一堆路由器里找到代言人来运行BGP协议，然后告诉周边的AS，自己周边AS的路径情况、可达性、延迟等等东西。使得AS和AS之间通信的时候可以正确的发包。注意是正确的发包，比如数据包被要求不要经过某些地区等也是正确，正确不代表路径延迟一定要最优。

# 总结

从一个小型网络开始可以看出路由策略需要正确设置才能通信；大型网络有成千上万的设备，全靠人是不行的，需要路由器自己彼此之间能互通有无，即路由协议；路由协议主要分为IGP和EGP两种，一种是AS内部自己用的，一种是AS之间彼此交换信息的
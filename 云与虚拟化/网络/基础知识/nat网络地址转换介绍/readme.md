# 家里的机器如何上网

家里的机器能上网，其路由路径如下图所示

```plantuml
@startuml
!include  https://plantuml.s3.cn-north-1.jdcloud-oss.com/C4_Container.puml

Boundary(子网1, 子网, 192.168.0.0/24) {
    System(主机1, 192.168.0.108, 我的电脑/LAN口)
    Container(port1, 192.168.0.1, 路由器网关)
    主机1<-r-> port1
}
Boundary(子网2, 子网, 192.168.1.0/24) {
    System(主机2, 192.168.1.1, 联网光猫) #orange
    Container(port2, 192.168.1.2, WAN口)
    port2 <-r-> 主机2
}

System(网站, 网站)

System(路由器, 家用路由器) #red
port1 <-u-> 路由器
路由器 <--> port2
主机2 <--> 网站
@enduml
```

意味着个人计算机通过家用路由器的网关功能将数据交给家用路由器，家用路由器再将它转交给光猫实现的内部数据到达互联网。

不过数据的流向是双向的，服务器收到请求回会给请求端回包

![回包.png](%E5%9B%9E%E5%8C%85.png)

有没有思考过，为什么网站能把数据包回给我的家用电脑，我的家用电脑的ip不是我的局域网ip么，这个数据怎么跑回来的？

```plantuml
@startuml
!include  https://plantuml.s3.cn-north-1.jdcloud-oss.com/C4_Container.puml

Boundary(子网1, 子网, 192.168.0.0/24) {
System(主机1, 192.168.0.108, 我的电脑/LAN口)
Container(port1, 192.168.0.1, 路由器网关)
主机1<-r-> port1
}
Boundary(子网2, 子网, 192.168.1.0/24) {
System(主机2, 192.168.1.1, 联网光猫) #orange
Container(port2, 192.168.1.2, WAN口)
port2 <-r-> 主机2
}

Boundary(机房, 机房) {
    System(网站, 网站)
    System(192.168.0.108, 192.168.0.108, 其它服务器)
}

System(路由器, 家用路由器) #red
port1 <-u-> 路由器
路由器 <--> port2
主机2 <--> 网站
网站 -[dashed]l->192.168.0.108: 为什么数据不往这发？
@enduml
```

上图中假设网站所在的机房也有一台机器ip是192.168.0.108，按照回包的目标地址，为啥不是这台机器收到数据？
192.168.0.0/24的网段是内网网段，任何公司、企业、家庭都会使用这个网段，为啥这个数据不转发给这些人，而是回到了正确的机器上。
原因是因为nat网络地址转换做了文章。

# snat(源地址映射转换)

nat提供的一种功能是snat，也就是对发送源的地址进行转换。
说白了就是改写ip包的源地址字段后转发，使得接收端认为这个包应当回给网关而不是原始发出包的主机，网关收到数据后再将数据包的目的端改回发包的主机地址。

## 一个简单粗暴的例子

假设 192.168.0.108 -> 6.6.6.6，其中192.168.0.108/24网段的网关是192.168.0.1，而这个家用路由器的公网ip是7.7.7.7

数据包将这么被转换

* 首先是192.168.0.108 发给 192.168.0.1的三层ip包:

```json
{
  "src": "192.168.0.108",
  "dst": "6.6.6.6"
}
```

* 192.168.0.1向互联网发的ip包:

```json
{
  "src": "7.7.7.7",
  "dst": "6.6.6.6"
}
```

这里ip源地址被改变，变成了7.7.7.7

* 6.6.6.6的回包

```json
{
  "src": "6.6.6.6",
  "dst": "7.7.7.7"
}
```

此时注意回包的ip是家用路由器的地址，而不是192.168.0.108(即发送源)

* 家用路由器查映射表发现这个包应当回给192.168.0.108，于是构造这个ip数据包转发

```json
{
  "src": "6.6.6.6",
  "dst": "192.168.0.108"
}
```

路由器看到是同子网，查arp表找到192.168.0.108的mac，直接二层封装后投递

## 如何对地址进行映射

在讲解地址转换的机制之前，首先需要认知到，tcp和udp协议有端口号的概念，其中以tcp协议为例子，数据从
192.168.0.108:16890发出，需要6.6.6.6:443端口接收。
6.6.6.6的数据不能随便从一个任意的端口返回，也需要从6.6.6.6:443发出，回给192.168.0.108:16890

于是，在snat上，服务将192.168.0.108:16890|6.6.6.6:443这对进行记录，然后通常才用和源主机一样的端口(在此是16890)修改源ip并转发改数据包

```json
{
  "src": {
    "addr": "7.7.7.7",
    "port": 16890
  },
  "dst": {
    "addr": "6.6.6.6",
    "port": 443
  }
}
```

关系对照表更新为 "192.168.0.108:16890|6.6.6.6:443 <-> 7.7.7.7:16890|6.6.6.6:443"

根据tcp协议的原理，回包为

```json
{
  "src": {
    "addr": "6.6.6.6",
    "port": 443
  },
  "dst": {
    "addr": "7.7.7.7",
    "port": 16890
  }
}
```

这时snat查记录表，知道这个数据是应当回给192.168.0.108:1689

snat的配置可通过iptables完成:

```shell
iptable -t nat -A POSTROUTING -o eth1 -j MASQUERADE
```

或者

```shell
iptables -t  nat -A  POSTROUTING -s 192.168.1.0/24 -o eth0  -j  SNAT --to-source x.x.x.x
```

MASQUERADE叫做伪装，用于那种出网ip不怎么固定的情况，比如adsl拨号上网

-o 是指定转发的网卡，这个网卡需要是能出网的那个

# dnat

dnat是反向的映射
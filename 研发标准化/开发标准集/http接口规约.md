# 提供的标准接口形式

本文约定，组件对外提供的编程接口原则上为基于<font color=red>http</font>协议的<font color=red>rest api</font>

# 字符集

除非特别约定，否则使用<font color=red>utf-8</font>字符集

# http动词约定

本文约定

* "GET"用于执行查询，该动作不得携带任何请求体
* "POST"用于执行创建记录，若记录已经存在则不得执行覆盖
* "PUT"用于覆盖已有记录，若记录不存在则新建
* "DELETE"用于删除给定记录
* "PATCH"用于变更给定记录的指定字段

# 请求体参数&响应内容约定

本文约定，除非编程接口需要遵守已有的国际规范或用于传输文件，否则使用<font color=red>json</font>作为标准数据格式。
不过，"GET"请求不得携带请求体。json数据内的属性字段一改按照“camel"形式进行命名，如

```json
{
  "thisIsCamel": "符合规定的camel风格命名",
  "this_is_snake": "不符合规定的snake风格"
}
```

不得携带"$"、数字等无法作为编程语言变量名的字符

# 请求参数类型约定

本文约定

* 在请求参数中提交的时间编码为带有时区信息的<font color=red>ISO-8601</font>字符串，
  <font color=red>禁止</font>使用整形时间戳。
  所有时间的精度为毫秒，ISO-8601字符串可以没有时间戳，其含义是0毫秒

# PATCH动词的语义表达

当执行PATCH对指定字段进行修改时，传参包含字段的值以及生效的字段清单，如

```json
{
  "name": null,
  "age": 80,
  "fields": [
    "name",
    "age"
  ]
}
```

这样使得调用方能够在某些参数字段不出现时规避后台程序错误地将字段修改为null的状况。

例如

```json
{
  "age": 80,
  "fields": [
    "name",
    "age"
  ]
}
```

在参数中, "name"没有出现，但是从语义上，name被视作应当修改为"null"

# 接口路径前缀约定

本文约定，所有编程接口首先附加前缀为"/api"。并

* 开放给web页面使用的接口附加统一前缀"/ui“，型为"/ui/api"
* 开放给外部客户端和探针使用的接口使用统一前缀"/open"，型为"/open/api"

# 接口错误表达

本文约定，接口的工作<font color=red>不使用</font>诸如"code"、"status"等表达状态的数据字段。
只使用http状态码来表达调用是否成功，其中

* 200表示调用成功并一般会有数据返回
* 204代表调用成功但不需要有数据返回
* 400代表较为通用的请求方错误，但不得包含未登录和禁止访问两种语义
* 402代表调用方已经欠费(如服务已经到达时间终点、购买的调用次数/流量已经全部耗尽等)
* 401&403代表请求方未登录和操作被禁止
* 404代表请求的资源不存在，同时允许使用400进行表达，这是因为部分客户端会将404认为是资源不存在而不是调用有错误
* 429代表请求过于频繁，比如单位时间的调用次数超过流控策略(例如1分钟内多次请求手机验证码的发送接口)以及常见的防重复提交
* 500代表服务端错误，因此应当自觉地通过4xx将调用方的问题和后台的问题进行区分
* 503代表服务端有错误但是可能过段时间就能自己恢复(比如内部某个模块正在重新加载)
* 502 & 504仅用于网关

# 标准错误结构体

```json
{
  "timestamp": "2022-08-22T11:50:16.017+00:00",
  "status": 410,
  "reason": "Gone",
  "uri": "/controller/exception",
  "error": "io.gardenerframework.fragrans.api.standard.error.exception.client.GoneException",
  "message": "资源已被永久移除",
  "hint": null,
  "details": null
}
```

上例展示了标准错误结构体

* "timestamp"为ISO-8601时间字符串
* "status"为http状态码，要求和http的响应一致。不能http响应是200，但"status"表示了错误
* "reason"为http状态码表达的http reason phrase，如"Not Found"
* "uri"为出现错误的调用地址
* "error"为内部的错误编码，用于开发人员快速定位代码或原因
* "message"为错误编码对应的文字描述
* "details"&"hint"为可选字段，含义是详细的错误内容(比如调用栈)和提示(如查看某个帮助文档的url)

基于上例，要求接口开发人员，除去遵守某种现有的接口规范外，必须在错误时给出标准错误的结构体

# rest路径和操作约定

本文遵守rest的调用规范，使用http动词表达调用语义，并使用路径来表达被操作的资源位置。

* "post /user"表示创建一个用户
* "put /user/123"表示覆盖id为123的用户
* "delete /user/123"表示删除id为123的用户

要求禁止使用 "post + 路径 + json参数"的传统api的调用方法，例如

* "post /createUser"
* "post /freezeUser"
* "post /unfreezeUser"
* "post /resetUserPassword"
* ...

一个用户管理就造成了接口数量爆炸

## 单词命名规范

本文约定，路径上的单词必须为名词，且使用单数形式，例如
"post /user"，而不是"post /createUser(包含动词)"或"post /users(不是单数)"。

若被操作资源难以使用一个单词来表达，则通过连字符"-"来连接单词，如
"post /native-user"

不使用复数的原因很简单，大家英文都不好，没时间记住那些单词是集合名词，那些单词是不可数名词

## 关系数据路径归属

### 明确的从属关系的路径归属

明确的从属关系是指2个不同的实体具有1:1或者1:n的对应关系，如用户(user)的个人设置文件(profile)。
此时设置文件不会独立于用户而存在，即用户是"聚合根"。
于是路径的表达为"/user/{userId}/profile"，无论是查询还是修改亦或是新建，都能清楚的感知到数据的从属关系以及必要的操作参数
(如用户的id)。

### 无从属关系的路径归属

无从属关系是指两个实体不具有严格的从属关系，例如学生选课这件事包含了学生(student)和课程(class)，两者之间没有强从属约束。
从逻辑上既可以理解为学生名下有若干课程，也可以理解为课程内有若干要上课的学生，即n:n映射
此时的路径设置容易产生混乱。

那么，在此的原则是

* 首先，学生和课程各自有各自的接口路径"/student"和"/class"用于自己数据的维护
* 按照给定课程查询学生的接口由"GET /student?class=..."承担，因为最终查询的结果返回的是学生
* 按照给定学生查询他选择了那些课程的接口由"GET /class?studentId=..."承担，因为最终接口返回的是课程
* 课程与学生的关系的创建以及修改则由"POST /student:select(remove)-class"承担，
  原因是学生能够选择课程(从逻辑的角度看，学生是数据关系建立的主动方)，
  而课程不能选择学生(数据关系建立的被动方)。
* 同理例如商户与消费者之间的关系建立，首先然也是各有各的接口。而从逻辑上出发，消费者选择商户，因此由消费者的路径来承担关系建立以及维护的接口。
  例如消费者关注商户的业务操作或者取消关注的业务操作，甚至是商户主动移除部分消费者的操作(等价于取关)。
  而查询数据时，查什么数据由什么数据实体的接口地址来承担

## http动作扩展

部分情况下使用http动词无法完整表达所有操作语义，比如任务的启动，暂停，继续。
而使用已有语义对业务进行生搬硬套又导致接口路径晦涩难懂，于是此时允许使用以下例子的rest风格路径:

"post /task/{taskId}:start"

* 请求以post动词开始
* 路径依旧为rest风格
* ":"后跟随执行的动作比如"start"/"stop"等

在比如客户端的激活和停用

* "post /client/{clientId}:enable"
* "post /client/{clientId}:disable"
